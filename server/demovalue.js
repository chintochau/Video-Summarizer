export const jsonDemo = {
  text: "‰∏çÁü•ÈÅìÂ§ßÂÆ∂ÊòØÂê¶‰πüÂíåÊàë‰∏ÄÊ†∑ Ëá™‰ªéËøô‰∏™ChatGPTÈóÆ‰∏ñ‰ª•Âêé ÊàëÂü∫Êú¨‰∏äÊØèÂ§©ÈÉΩÁ¶ª‰∏çÂºÄÂÆÉ‰∫Ü Â∞èÂà∞Êí∞ÂÜôÈÇÆ‰ª∂ ÂÜÖÂÆπÁÇπÂ≠ê Â§ßÂà∞ÂïÜ‰∏öËßÑÂàí Ëê•ÈîÄÁ≠ñÂàí ÊàëÂü∫Êú¨‰∏äÈÉΩË¶ÅÂéªÂí®ËØ¢ChatGPTÁöÑÊÑèËßÅ ËÄå‰∏îÂá†‰πéÊ≤°Êúâ‰æãÂ§ñÁöÑ ÊØè‰∏ÄÊ¨°ÊàëÈÉΩËÉΩÂ§üÂæóÂà∞ÊØîËæÉÊª°ÊÑèÁöÑÂõûÁ≠î ËÄå‰∏îÊÄªÊòØËÉΩÂ§üËé∑Âæó‰∏Ä‰∫õÊñ∞ÁöÑÂêØÂèëÊàñËÄÖÁÇπÂ≠ê ÊâÄ‰ª•ÂΩìÊàëÁü•ÈÅìËøô‰∏™ChatGPT4 ‰∏ç‰ªÖÂèØ‰ª•‰∏äÁΩë ËÄå‰∏îËøòÂèØ‰ª•ÂíåÁ¨¨‰∏âÊñπÁöÑ‰∏Ä‰∫õËΩØ‰ª∂ ËøõË°åÁõ∏ËøûÊé•ÁöÑÊó∂ÂÄô ÊàëÂü∫Êú¨‰∏äÊòØÊØ´‰∏çÁäπË±´ÁöÑÂ∞±Á´ãÈ©¨‰∏ãÂçï ÂçáÁ∫ß‰∫ÜÊàëÁöÑChatGPT ÁõÆÂâçÁªèËøá‰∫ÜÂá†‰∏™Âë®ÁöÑÊµãËØï ÊàëÂèØ‰ª•ÈùûÂ∏∏Ëá™‰ø°ÁöÑÂëäËØâÂ§ßÂÆ∂ Ëøô‰∏™Èí±Ëä±ÁöÑÂÄº ‰ªäÂ§©ÊàëÂ∞±ÁªôÂ§ßÂÆ∂Êù•‰ªãÁªçÂá†Ê¨æ ÈùûÂ∏∏ÈùûÂ∏∏Â•ΩÁî®ÁöÑChatGPTÊèí‰ª∂ ËÉΩÂ§üËÆ©‰Ω†ÁöÑÂ∑•‰ΩúÂíåÁîüÊ¥ªÊõ¥Âä†ÁöÑÈ´òÊïà ËÆ©‰Ω†‰ªø‰ΩõÂ¶ÇÊúâÁ•ûÂä© Â¶ÇËôéÊ∑ªÁøº È¶ñÂÖàË¶ÅÁªôÂ§ßÂÆ∂‰ªãÁªçÁöÑÁ¨¨‰∏ÄÊ¨æÊèí‰ª∂",
};

export const srtDdemo = `1
00:00:00,000 --> 00:00:01,480
‰∏çÁü•ÈÅìÂ§ßÂÆ∂ÊòØÂê¶‰πüÂíåÊàë‰∏ÄÊ†∑

2
00:00:01,480 --> 00:00:03,440
Ëá™‰ªéËøô‰∏™ChatGPTÈóÆ‰∏ñ‰ª•Âêé

3
00:00:03,440 --> 00:00:05,400
ÊàëÂü∫Êú¨‰∏äÊØèÂ§©ÈÉΩÁ¶ª‰∏çÂºÄÂÆÉ‰∫Ü

4
00:00:05,400 --> 00:00:06,760
Â∞èÂà∞Êí∞ÂÜôÈÇÆ‰ª∂

5
00:00:06,760 --> 00:00:07,600
ÂÜÖÂÆπÁÇπÂ≠ê

6
00:00:07,600 --> 00:00:09,120
Â§ßÂà∞ÂïÜ‰∏öËßÑÂàí

7
00:00:09,120 --> 00:00:09,960
Ëê•ÈîÄÁ≠ñÂàí

8
00:00:09,960 --> 00:00:12,960
ÊàëÂü∫Êú¨‰∏äÈÉΩË¶ÅÂéªÂí®ËØ¢ChatGPTÁöÑÊÑèËßÅ

9
00:00:12,960 --> 00:00:14,840
ËÄå‰∏îÂá†‰πéÊ≤°Êúâ‰æãÂ§ñÁöÑ

10
00:00:14,840 --> 00:00:17,719
ÊØè‰∏ÄÊ¨°ÊàëÈÉΩËÉΩÂ§üÂæóÂà∞ÊØîËæÉÊª°ÊÑèÁöÑÂõûÁ≠î

11
00:00:17,719 --> 00:00:21,120
ËÄå‰∏îÊÄªÊòØËÉΩÂ§üËé∑Âæó‰∏Ä‰∫õÊñ∞ÁöÑÂêØÂèëÊàñËÄÖÁÇπÂ≠ê

12
00:00:21,120 --> 00:00:23,400
ÊâÄ‰ª•ÂΩìÊàëÁü•ÈÅìËøô‰∏™ChatGPT4

13
00:00:23,400 --> 00:00:24,520
‰∏ç‰ªÖÂèØ‰ª•‰∏äÁΩë

14
00:00:24,520 --> 00:00:27,160
ËÄå‰∏îËøòÂèØ‰ª•ÂíåÁ¨¨‰∏âÊñπÁöÑ‰∏Ä‰∫õËΩØ‰ª∂

15
00:00:27,160 --> 00:00:28,760
ËøõË°åÁõ∏ËøûÊé•ÁöÑÊó∂ÂÄô

16
00:00:28,760 --> 00:00:31,639
ÊàëÂü∫Êú¨‰∏äÊòØÊØ´‰∏çÁäπË±´ÁöÑÂ∞±Á´ãÈ©¨‰∏ãÂçï

17
00:00:31,639 --> 00:00:33,400
ÂçáÁ∫ß‰∫ÜÊàëÁöÑChatGPT

18
00:00:33,400 --> 00:00:35,560
ÁõÆÂâçÁªèËøá‰∫ÜÂá†‰∏™Âë®ÁöÑÊµãËØï

19
00:00:35,560 --> 00:00:37,639
ÊàëÂèØ‰ª•ÈùûÂ∏∏Ëá™‰ø°ÁöÑÂëäËØâÂ§ßÂÆ∂

20
00:00:37,639 --> 00:00:39,480
Ëøô‰∏™Èí±Ëä±ÁöÑÂÄº

21
00:00:39,480 --> 00:00:41,400
‰ªäÂ§©ÊàëÂ∞±ÁªôÂ§ßÂÆ∂Êù•‰ªãÁªçÂá†Ê¨æ

22
00:00:41,400 --> 00:00:43,799
ÈùûÂ∏∏ÈùûÂ∏∏Â•ΩÁî®ÁöÑChatGPTÊèí‰ª∂

23
00:00:43,799 --> 00:00:46,680
ËÉΩÂ§üËÆ©‰Ω†ÁöÑÂ∑•‰ΩúÂíåÁîüÊ¥ªÊõ¥Âä†ÁöÑÈ´òÊïà

24
00:00:46,680 --> 00:00:48,439
ËÆ©‰Ω†‰ªø‰ΩõÂ¶ÇÊúâÁ•ûÂä©

25
00:00:48,439 --> 00:00:49,480
Â¶ÇËôéÊ∑ªÁøº

26
00:00:52,040 --> 00:00:54,200
È¶ñÂÖàË¶ÅÁªôÂ§ßÂÆ∂‰ªãÁªçÁöÑÁ¨¨‰∏ÄÊ¨æÊèí‰ª∂


`;

export const youtubeDemoTranscript = [
  {
    text: "In this video we be visiting the most popular Flowing Noodles Bamboo River restaurant in Japan",
    duration: 8620,
    offset: 12187,
  },
  {
    text: "They will serve this special summer dish from May to September each year",
    duration: 7407,
    offset: 22155,
  },
  {
    text: "It is located in Kyoto and requires us to go up a Mountain",
    duration: 9520,
    offset: 32210,
  },
  {
    text: "The public bus will drop us around 15 minutes walk from the restaurant",
    duration: 5818,
    offset: 42431,
  },
  {
    text: "Along the way you can find Shrines and other authentic Japanese restaurants",
    duration: 6719,
    offset: 48749,
  },
  {
    text: "It is a beautiful scenic walk up",
    duration: 10010,
    offset: 55972,
  },
  {
    text: "With also many giant spiderwebs and spiders!",
    duration: 5288,
    offset: 66483,
  },
  {
    text: "We have reached the place and it is called ‚ÄúHirobun‚Äù",
    duration: 4738,
    offset: 72272,
  },
  {
    text: "Part of is a Ryokan (Japanese Style Hotel)",
    duration: 6790,
    offset: 77510,
  },
  {
    text: "The restaurant portion sits on top of the river",
    duration: 5587,
    offset: 84678,
  },
  {
    text: "Though the restaurant only opens at 11am",
    duration: 2314,
    offset: 90779,
  },
  {
    text: "There is already a long line of people waiting",
    duration: 2886,
    offset: 93593,
  },
  {
    text: "We are finally inside!",
    duration: 3370,
    offset: 103620,
  },
  {
    text: "It doesn‚Äôt have a proper roof though, so it will actually close if it rains",
    duration: 6440,
    offset: 107490,
  },
  {
    text: "We are first put at the most bottom part which is called the ‚Äúwaiting area‚Äù",
    duration: 6624,
    offset: 114380,
  },
  {
    text: "Here we can educated ourselves with rules while we wait somemore",
    duration: 8792,
    offset: 121504,
  },
  {
    text: "The flowing river does look inviting I must say",
    duration: 3387,
    offset: 134267,
  },
  {
    text: "Another amazing spiderweb and spider combo sits casually at the corner",
    duration: 6507,
    offset: 138354,
  },
  {
    text: "We go up to the next stage when our number gets called",
    duration: 3020,
    offset: 148231,
  },
  {
    text: "Now we are just 1 step away from eating!",
    duration: 2870,
    offset: 154954,
  },
  {
    text: "Some instructions is given at this spot",
    duration: 4922,
    offset: 159759,
  },
  {
    text: "It will be a fast pace course so the pink noodle will let you know when it ends",
    duration: 5372,
    offset: 165765,
  },
  {
    text: "A beautiful mini waterfall will be the backdrop for flowing noodle customers",
    duration: 6340,
    offset: 171571,
  },
  {
    text: "At the top is actually their main restaurant where they serve complete Japanese meal courses",
    duration: 7441,
    offset: 178444,
  },
  {
    text: "For our dining concept, the noodles will basically flow out from bamboo poles",
    duration: 8123,
    offset: 186386,
  },
  {
    text: "It is then up to the customers to catch it!",
    duration: 4321,
    offset: 195011,
  },
  {
    text: "A staff will be in this booth feeding each pole",
    duration: 3087,
    offset: 199849,
  },
  {
    text: "You can‚Äôt really see them while they do that",
    duration: 5773,
    offset: 203469,
  },
  {
    text: "So noodles will slide out unexpectedly!",
    duration: 7725,
    offset: 209742,
  },
  {
    text: "Uncaught noodles will end up at the bottom",
    duration: 3567,
    offset: 217754,
  },
  {
    text: "It has been about 12 minutes and the customers in front of us has ended their course",
    duration: 4121,
    offset: 221821,
  },
  {
    text: "Staffs will clean up the area and plate it up before we are seated",
    duration: 6023,
    offset: 226442,
  },
  {
    text: "There was also a clearing of the uncaught noodles which would be about 4 hours worth",
    duration: 4955,
    offset: 232966,
  },
  {
    text: "Here would be our table",
    duration: 2569,
    offset: 238388,
  },
  {
    text: "We are allocated the most bottom lane",
    duration: 2503,
    offset: 241457,
  },
  {
    text: "The same group will share a bamboo pole meaning 3 different groups of people can be fed here",
    duration: 6189,
    offset: 244544,
  },
  {
    text: "The allocated lanes will go from bottom to top to prevent contamination from chopstick drippings",
    duration: 5055,
    offset: 251067,
  },
  {
    text: "We are eagerly waiting our noodles",
    duration: 5389,
    offset: 256639,
  },
  {
    text: "Caught it!",
    duration: 3003,
    offset: 280613,
  },
  {
    text: "We just put it in the provided dipping sauce to enjoy!",
    duration: 5873,
    offset: 284083,
  },
  {
    text: "It a cold type of noodle that gives you a bouncy chew",
    duration: 3003,
    offset: 291591,
  },
  {
    text: "A dab of wasabi at the side is also provide for some added heat",
    duration: 5271,
    offset: 295662,
  },
  {
    text: "Catching it is such beautiful moment given your surroundings",
    duration: 4909,
    offset: 304800,
  },
  {
    text: "And also exciting!",
    duration: 6523,
    offset: 311694,
  },
  {
    text: "You are always on your toes",
    duration: 4705,
    offset: 323122,
  },
  {
    text: "Cause you do not want to miss your high speed flowing noodle!",
    duration: 5205,
    offset: 329012,
  },
  {
    text: "But ya basically this would be our main meal here",
    duration: 6690,
    offset: 347430,
  },
  {
    text: "The noodle is called Somen, a thin rice noodle",
    duration: 5672,
    offset: 356773,
  },
  {
    text: "And the dipping sauce is Soya base with added bonito flavoring",
    duration: 5305,
    offset: 364280,
  },
  {
    text: "Which is refreshing and salty at the same time",
    duration: 5489,
    offset: 371037,
  },
  {
    text: "Together they make a light tasty meal great for cooling you down in summers",
    duration: 6123,
    offset: 392258,
  },
  {
    text: "The pink noodles have come signifying the end to our courses!",
    duration: 5539,
    offset: 403970,
  },
  {
    text: "Each person in the group will get a bundle",
    duration: 5088,
    offset: 413129,
  },
  {
    text: "I am not sure what happened to my eyes then, but I totally miss my portion!",
    duration: 5105,
    offset: 428811,
  },
  {
    text: "It is a good thing my partner manage to caught hers",
    duration: 7390,
    offset: 436586,
  },
  {
    text: "A closer look at the pink noodle",
    duration: 3670,
    offset: 447530,
  },
  {
    text: "Last we have a dessert of Warabi Mochi to end our course",
    duration: 4819,
    offset: 451702,
  },
  {
    text: "Unlike usual mochi which is made of glutinous rice, this mochi is made with braken starch",
    duration: 6204,
    offset: 457020,
  },
  {
    text: "Making it more jelly-like and chewy",
    duration: 4136,
    offset: 465423,
  },
  {
    text: "A squishy and tasty sweet ending!",
    duration: 7555,
    offset: 474443,
  },
  {
    text: "Now like all crowded Japanese restaurants, we better run off once we are done",
    duration: 3640,
    offset: 483213,
  },
  {
    text: "Overall though the meal of this place was of such simple ingredients",
    duration: 5437,
    offset: 487531,
  },
  {
    text: "It offered such a unique and immersive experience that was both enjoyable and fun",
    duration: 8019,
    offset: 493482,
  },
];

export const presetPrompt = `
" Your output should use the following template:

### Summary

### Analogy

### Notes

- [Emoji] Bulletpoint

### Keywords

- Explanation



You have been tasked with creating a concise summary of a YouTube video using its transcription.



Make a summary of the transcript.



Additionally make a short complex analogy to give context and/or analogy from day-to-day life from the transcript.



Create 10 bullet points (each with an appropriate emoji) that summarize the key points or important moments from the video's transcription.



In addition to the bullet points, extract the most important keywords and any complex words not known to the average reader aswell as any acronyms mentioned. For each keyword and complex word, provide an explanation and definition based on its occurrence in the transcription.



Please ensure that the summary, bullet points, and explanations fit within the 330-word limit, while still offering a comprehensive and clear understanding of the video's content. Use the text above: {{Title}} {{Transcript}}. "`;


export const demoTranscript2 = `00:00:00 :
what's up guys Terrace cousin here back
00:00:02 :
with another tutorial in this one we're
00:00:04 :
going to take a look at use ref a very
00:00:06 :
powerful hook that is used whenever you
00:00:08 :
want to reference a value that is not
00:00:10 :
needed for rendering make sure to watch
00:00:12 :
until the end of the video because I'm
00:00:14 :
really going to be covering everything
00:00:15 :
there is to know about userf and also
00:00:18 :
some very important points that if you
00:00:20 :
do watch until the end I can promise you
00:00:22 :
that you're most likely not going to
00:00:24 :
have to need to watch another video on
00:00:26 :
use ref ever again sound good cool let's
00:00:30 :
jump on my computer screen and talk
00:00:31 :
about use ref cool so use ref honestly
00:00:35 :
I've thought about this quite a while
00:00:37 :
and I think the best way and the
00:00:39 :
simplest way to really think about this
00:00:40 :
is think about ref as state something
00:00:43 :
similar to state in the sense that you
00:00:45 :
can hold and mutate values that are used
00:00:48 :
in your component but the main
00:00:50 :
difference is that unlike State ref does
00:00:53 :
not trigger a re-render of the component
00:00:55 :
and ref values are not used in the
00:00:59 :
return body of the actual component it's
00:01:02 :
not used for something that you're
00:01:04 :
rendering it's a hook that is used for
00:01:06 :
values that are not needed for rendering
00:01:08 :
so the best way for us to really
00:01:10 :
understand this is to look at the simple
00:01:12 :
example that I have here and compare
00:01:14 :
state to ref and see how they both
00:01:16 :
behave and see the differences between
00:01:18 :
the two so this application here as you
00:01:21 :
can see is really simple it has a count
00:01:23 :
from state right a discount variable
00:01:25 :
here uses use state it is initialized to
00:01:28 :
zero we have the set count of data
00:01:30 :
function to update it and by the way if
00:01:32 :
you're not familiar with ustate I have a
00:01:34 :
whole video about that it's in the same
00:01:35 :
playlist that you're watching this video
00:01:37 :
now so if you're unfamiliar you want to
00:01:39 :
learn more about your state make sure to
00:01:40 :
go check out that video first then we
00:01:43 :
have another count but this one through
00:01:46 :
use ref and this one as well is
00:01:48 :
initialized with a value of zero then we
00:01:50 :
have this handle increment function
00:01:52 :
which is attached to this button right
00:01:54 :
here and when clicked it will first set
00:01:56 :
the count to count plus one so update
00:01:59 :
this State count to count plus 1
00:02:02 :
incremented by one and then it will do
00:02:05 :
the same thing to the ref it will
00:02:07 :
increment the ref by one now this dot
00:02:10 :
current thing here is actually how you
00:02:13 :
access values and how you mutate values
00:02:15 :
in your ref the value of a ref is always
00:02:18 :
going to be inside of this dot current
00:02:20 :
property whatever the value is in our
00:02:22 :
case it's zero it's a number if it was
00:02:24 :
an input if it was anything else you
00:02:26 :
would always access and mutate it with
00:02:28 :
the dot current property so this line
00:02:30 :
here 11 is just taking the value and
00:02:33 :
it's doing plus plus which is Javascript
00:02:35 :
notation for incremented by one so these
00:02:38 :
two lines are doing the same thing just
00:02:40 :
for both pieces of not state but both
00:02:43 :
counts essentially
00:02:45 :
and then we are logging the state count
00:02:48 :
and we are logging the ref count right
00:02:52 :
so let's see what happens if I do this
00:02:54 :
if I open up the console
00:02:56 :
and then clear everything what will
00:02:58 :
happen when I press increment so I press
00:03:00 :
increment and first of all the count has
00:03:03 :
been updated to one because the count
00:03:05 :
here is used in this return function and
00:03:07 :
it's displayed here this is the count
00:03:09 :
from the state so the state count we
00:03:11 :
know that is now 1 as a result of me
00:03:14 :
pressing this increment button if we
00:03:16 :
look here at the console we're going to
00:03:18 :
see that state logged as 0 and ref
00:03:21 :
locked as one now this is very
00:03:24 :
interesting and I want you to pay
00:03:26 :
attention because this is really
00:03:28 :
important that you understand why State
00:03:30 :
logged is zero and why ref log this one
00:03:33 :
so looking at this function here let's
00:03:36 :
first talk about the state right we are
00:03:38 :
incrementing the state and then we are
00:03:40 :
console logging the state after it has
00:03:42 :
been incremented just like I talked
00:03:45 :
about in the video that I did on you
00:03:46 :
State State updates one particular
00:03:49 :
property that they have is that they
00:03:51 :
happen and they trigger a new render a
00:03:54 :
new render of the component and the
00:03:56 :
updated value is only accessible in that
00:03:59 :
new render so what react is going to do
00:04:02 :
when we do this set count count plus one
00:04:04 :
is it's going to update the state of
00:04:06 :
count to count plus one it's going to
00:04:09 :
then continue running the body of the
00:04:11 :
function running any other hooks or
00:04:13 :
anything else that we might have in this
00:04:15 :
component right it doesn't stop
00:04:18 :
rendering altogether just because we're
00:04:20 :
updating the state it's going to
00:04:21 :
continue to finish the work and then
00:04:23 :
once all of the work has been done it's
00:04:25 :
going to then trigger a re-render
00:04:28 :
and that we render is going to have
00:04:30 :
access to the new value which is how
00:04:33 :
we're seeing it here on the screen right
00:04:35 :
this is because the component has
00:04:37 :
re-rendered since we press this
00:04:38 :
increment button and in that next render
00:04:41 :
we have access to the new updated value
00:04:44 :
which is one however this console log
00:04:48 :
here is not running in the next render
00:04:51 :
it's still running in that first initial
00:04:53 :
render when we click the button so when
00:04:56 :
even though we did set count here that
00:04:58 :
value as we said is only accessible in
00:05:01 :
the next render and so this console log
00:05:04 :
here is going to reference the old value
00:05:06 :
which was zero right that is how you
00:05:08 :
state Works only in the next render
00:05:11 :
which in our case only when we press
00:05:13 :
this increment button again will we then
00:05:15 :
have access to the new value of that
00:05:17 :
previous render so if I do this
00:05:19 :
you see that now we have access to State
00:05:22 :
one right that was the updated value of
00:05:25 :
the previous render however as you can
00:05:27 :
see now we're at count two right we're
00:05:30 :
always lacking behind one render that is
00:05:33 :
okay that is normal that is how you
00:05:35 :
state works right but now if you look at
00:05:38 :
ref it's different ref right logged one
00:05:43 :
right off the bat and then I press the
00:05:45 :
button again and it logged two right off
00:05:48 :
the bat so it functions very differently
00:05:50 :
than you state and that's okay that's
00:05:52 :
expected
00:05:53 :
ref will allow you to make updates and
00:05:57 :
to read the updated value instantly
00:06:00 :
without waiting for a re-render and the
00:06:03 :
reason you don't wait for a re-render is
00:06:05 :
because use ref doesn't even trigger a
00:06:08 :
new re-render in the first place that's
00:06:10 :
not what it's for if you need a new
00:06:12 :
re-render then you have to use state if
00:06:15 :
you don't then you use use ref that is
00:06:17 :
what I meant in the beginning of the
00:06:19 :
video when I said that use ref is a hook
00:06:21 :
that is used for Value that is not
00:06:23 :
needed for rendering that is how we're
00:06:26 :
able to have access to this new value
00:06:27 :
right away so when you increment the
00:06:30 :
count of the ref here you can console
00:06:33 :
log it right away and get access to the
00:06:35 :
new value right away that is a property
00:06:37 :
of ref of use ref now let me drive your
00:06:40 :
attention to what happens if instead of
00:06:42 :
discount here instead of the state count
00:06:44 :
in our return function what happens if I
00:06:47 :
replace this with the ref so I'll do
00:06:50 :
ref.current counterf.current and then in
00:06:53 :
the increment function I'm just going to
00:06:55 :
get rid of anything about State because
00:06:58 :
I don't want to trigger a re-render
00:07:00 :
through state right I only want to
00:07:02 :
manipulate the ref and see how our
00:07:04 :
component behaves now so I'm just going
00:07:06 :
to refresh so we have a clean slate and
00:07:08 :
if I press increment the count stayed at
00:07:12 :
0 but the ref logged as one I press
00:07:16 :
increment again the count still stays at
00:07:18 :
zero but the ref locked at 2 right this
00:07:22 :
is interesting but by now hopefully it
00:07:25 :
should make sense refs do not cause a
00:07:28 :
component to re-render and so if you
00:07:31 :
were to use it inside of this return
00:07:32 :
function you would not get the updated
00:07:35 :
value because that does not trigger a
00:07:38 :
component to re-render you would only
00:07:40 :
get the updated value if you have
00:07:42 :
something else that triggers the
00:07:44 :
component to re-render for example if we
00:07:46 :
re-added the set count here and then
00:07:49 :
just refreshed we would increment again
00:07:52 :
and now we would see ref1 and count one
00:07:55 :
increment again ref2 and count two we're
00:07:58 :
getting the most up-to-date value but
00:08:00 :
not because of ref we're getting it
00:08:02 :
because of State because of this set
00:08:04 :
count here that is what is causing the
00:08:06 :
component to re-render to trigger a
00:08:08 :
re-render so that we get access to the
00:08:10 :
most up-to-date value and so that's what
00:08:13 :
I meant that you should never use ref
00:08:14 :
inside of this return function because
00:08:17 :
your application is not going to work as
00:08:19 :
expected and you're going to use ref for
00:08:22 :
something that is not intended to be
00:08:23 :
used for and now let's talk about
00:08:25 :
another use case of ref one that you
00:08:27 :
might be more familiar with which is
00:08:29 :
using it with input elements or any
00:08:31 :
other HTML element in this case I just
00:08:34 :
have a simple ref which can be of type
00:08:36 :
HTML input element or null and then we
00:08:39 :
are passing it here to this input
00:08:41 :
element inside of the return function so
00:08:44 :
this is fine right we're not using dot
00:08:46 :
current here we're just passing the
00:08:48 :
reference of the ref to this input
00:08:49 :
opponent and this is allowed this is one
00:08:52 :
of the only use cases where you can use
00:08:54 :
a ref directly in the return function
00:08:56 :
and the reason you do this is because if
00:08:58 :
you do that react is going to handle
00:09:01 :
setting the dot current property of the
00:09:04 :
ref to the input as long as it's mounted
00:09:06 :
right the moment that the input becomes
00:09:09 :
unmounted whether the component unmounts
00:09:10 :
or some other reason react is going to
00:09:13 :
automatically handle removing the dot
00:09:16 :
current from The Ref right so you get
00:09:17 :
that benefit if you do it this way and
00:09:20 :
doing it this way right you have a ref
00:09:22 :
you pass it here to the input you can
00:09:24 :
then access some of the functions from
00:09:27 :
that input like for example this Focus
00:09:29 :
function right here this use effect what
00:09:31 :
we'll do is when the component is
00:09:33 :
mounted and everything else is rendered
00:09:34 :
because hooks always run after things
00:09:36 :
are rendered this input ref will be set
00:09:39 :
by react automatically to this input and
00:09:42 :
then you can call input ref.current
00:09:44 :
question mark right because we've
00:09:46 :
defined it as a type that it can't be
00:09:48 :
null right so typescript does doesn't
00:09:50 :
know that react will automatically
00:09:51 :
handle this for us but you can call the
00:09:54 :
focus function on this input on Mount
00:09:57 :
right which is going to focus here if I
00:09:59 :
just refresh the page it's going to
00:10:01 :
automatically Focus the input on month
00:10:03 :
which is a very useful thing to have in
00:10:05 :
an application perhaps you have a form
00:10:07 :
right and you want to facilitate the
00:10:08 :
user experience by having the first
00:10:10 :
input that makes sense be automatically
00:10:12 :
focused on mobile that's also going to
00:10:14 :
trigger the keyboard right this is a
00:10:16 :
feature that you would want you would
00:10:17 :
have to use a ref to accomplish that
00:10:19 :
feature so refs beside using values that
00:10:22 :
are not needed for rendering are also
00:10:24 :
useful if you want to access directly
00:10:26 :
HTML Dom elements and call functions on
00:10:29 :
those elements you can also use it
00:10:31 :
perhaps you've used it as well with
00:10:33 :
third-party libraries that create a ref
00:10:35 :
and then expose that ref along with some
00:10:37 :
functions so that you can access from
00:10:39 :
anywhere the functions of inside of that
00:10:42 :
component that is also a use case for
00:10:44 :
ref although that's not usually one that
00:10:46 :
you would write yourself you would just
00:10:47 :
more generally create a ref and pass it
00:10:49 :
and then by the documentation to Sweet
00:10:51 :
of the different functions that you can
00:10:53 :
call and work on it that way still refs
00:10:56 :
are a very powerful feature in react and
00:10:58 :
you really have to spend the time to
00:11:00 :
understand how they work what they're
00:11:02 :
used for what's the difference between
00:11:03 :
ref and state and how you can use it
00:11:05 :
with elements and also in third-party
00:11:08 :
libraries please take the time to really
00:11:10 :
focus and pun intended right Focus
00:11:13 :
really focus and understand what ref is
00:11:16 :
and how to use it and you will be a much
00:11:17 :
better react developer cool so there you
00:11:20 :
go another tutorial in the books this
00:11:22 :
was used buff I really hope that now you
00:11:24 :
have a better understanding of this hook
00:11:25 :
and how to use it and you can now go and
00:11:28 :
work on it in your own applications try
00:11:30 :
it out try the difference between that
00:11:31 :
and state and like I said you will
00:11:33 :
become a much better developer spend all
00:11:35 :
the time that you need and that is
00:11:37 :
required to really properly understand
00:11:40 :
this if you've enjoyed this video if you
00:11:42 :
got any value from it whatsoever please
00:11:44 :
do make sure to leave a subscribe leave
00:11:46 :
a like because it really does help me
00:11:47 :
out a lot it shows me that you enjoy
00:11:49 :
this type of content and that you want
00:11:51 :
more and trust me as you can see I'm
00:11:53 :
publishing a lot of these tutorials and
00:11:55 :
there's a lot more coming I love doing
00:11:57 :
this also if you want to learn more
00:11:59 :
about react and just be part of a
00:12:02 :
community of react developers and also
00:12:04 :
have access to me to answer your
00:12:06 :
questions look at your code help you
00:12:08 :
become a better developer I've created a
00:12:11 :
Discord for react developers there's a
00:12:13 :
link in the description you can join
00:12:15 :
it's completely for free we have about
00:12:17 :
like a hundred members and growing and
00:12:19 :
I'm there every day answering questions
00:12:22 :
reviewing code and I'm trying to create
00:12:24 :
the best community of react developers
00:12:26 :
on the internet so if that's of interest
00:12:28 :
to you there's a link in the description
00:12:30 :
make sure to go there and join and I
00:12:32 :
would love to see you on the Discord
00:12:33 :
with that being said my name has been
00:12:35 :
there as cousin this is cousin Solutions
00:12:37 :
it's been an absolute pleasure and I'll
00:12:39 :
`


export const tempSummary = `
### Summary
The video is a tutorial on the use of the useRef hook in React, explaining its purpose in storing and mutating values that do not trigger re-renders in components.

### Analogy
Using useRef is like having a notepad to write down information that you want to reference quickly without needing to redraw the entire picture.

https://www.youtube.com/

### Notes
- üí° useRef is used for storing values that do not trigger component re-renders.
- üí° State in React triggers re-renders, while useRef does not.
- üí° useRef is useful for accessing and manipulating DOM elements directly.

### Keywords
- **useRef**: A React hook used for storing mutable values that do not trigger re-renders.
- **re-render**: The process of updating and refreshing the component's UI based on changes in state or props.

### Complex Words
- **useRef**: A built-in React hook used for storing values that do not trigger re-renders.
- **incremented**: To increase or add to a value.
- **re-render**: The process of updating and refreshing the component's appearance based on changes in state or props.
- **manipulate**: To handle or control something, often with the intention of changing it.`